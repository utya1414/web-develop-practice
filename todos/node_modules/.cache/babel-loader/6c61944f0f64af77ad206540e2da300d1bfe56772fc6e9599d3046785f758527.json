{"ast":null,"code":"import * as React from 'react';\nimport { Options, options, tokenize } from 'linkifyjs';\n\n/**\n * Given a string, converts to an array of valid React components\n * (which may include strings)\n * @param {string} str\n * @param {Options} opts\n * @param {{ [elementId: string]: number }} meta\n * @returns {React.ReactNodeArray}\n */\nfunction stringToElements(str, opts, meta) {\n  const tokens = tokenize(str);\n  const elements = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.t === 'nl' && opts.get('nl2br')) {\n      const key = `__linkify-el-${meta.elementId++}`;\n      elements.push(React.createElement('br', {\n        key\n      }));\n    } else if (!token.isLink || !opts.check(token)) {\n      // Regular text\n      elements.push(token.toString());\n    } else {\n      let rendered = opts.render(token);\n      if (!('key' in rendered.props)) {\n        // Ensure generated element has unique key\n        const key = `__linkify-el-${meta.elementId++}`;\n        const props = options.assign({\n          key\n        }, rendered.props);\n        rendered = React.cloneElement(rendered, props);\n      }\n      elements.push(rendered);\n    }\n  }\n  return elements;\n}\n\n// Recursively linkify the contents of the given React Element instance\n/**\n * @template P\n * @template {string | React.JSXElementConstructor<P>} T\n * @param {React.ReactElement<P, T>} element\n * @param {Options} opts\n * @param {{ [elementId: string]: number }} meta\n * @returns {React.ReactElement<P, T>}\n */\nfunction linkifyReactElement(element, opts, meta) {\n  if (React.Children.count(element.props.children) === 0) {\n    // No need to clone if the element had no children\n    return element;\n  }\n  const children = [];\n  React.Children.forEach(element.props.children, child => {\n    if (typeof child === 'string') {\n      // ensure that we always generate unique element IDs for keys\n      children.push.apply(children, stringToElements(child, opts, meta));\n    } else if (React.isValidElement(child)) {\n      if (typeof child.type === 'string' && opts.ignoreTags.indexOf(child.type.toUpperCase()) >= 0) {\n        // Don't linkify this element\n        children.push(child);\n      } else {\n        children.push(linkifyReactElement(child, opts, meta));\n      }\n    } else {\n      // Unknown element type, just push\n      children.push(child);\n    }\n  });\n\n  // Set a default unique key, copy over remaining props\n  const key = `__linkify-el-${meta.elementId++}`;\n  const newProps = options.assign({\n    key\n  }, element.props);\n  return React.cloneElement(element, newProps, children);\n}\n\n/**\n * @template P\n * @template {string | React.JSXElementConstructor<P>} T\n * @param {P & { as?: T, tagName?: T, options?: import('linkifyjs').Opts, children?: React.ReactNode}} props\n * @returns {React.ReactElement<P, T>}\n */\nconst Linkify = props => {\n  // Copy over all non-linkify-specific props\n  let linkId = 0;\n  const defaultLinkRender = _ref => {\n    let {\n      tagName,\n      attributes,\n      content\n    } = _ref;\n    attributes.key = `__linkify-lnk-${linkId++}`;\n    if (attributes.class) {\n      attributes.className = attributes.class;\n      delete attributes.class;\n    }\n    return React.createElement(tagName, attributes, content);\n  };\n  const newProps = {\n    key: '__linkify-wrapper'\n  };\n  for (const prop in props) {\n    if (prop !== 'options' && prop !== 'as' && prop !== 'tagName' && prop !== 'children') {\n      newProps[prop] = props[prop];\n    }\n  }\n  const opts = new Options(props.options, defaultLinkRender);\n  const as = props.as || props.tagName || React.Fragment || 'span';\n  const children = props.children;\n  const element = React.createElement(as, newProps, children);\n  return linkifyReactElement(element, opts, {\n    elementId: 0\n  });\n};\nexport { Linkify as default };","map":{"version":3,"names":["React","Options","options","tokenize","stringToElements","str","opts","meta","tokens","elements","i","length","token","t","get","key","elementId","push","createElement","isLink","check","toString","rendered","render","props","assign","cloneElement","linkifyReactElement","element","Children","count","children","forEach","child","apply","isValidElement","type","ignoreTags","indexOf","toUpperCase","newProps","Linkify","linkId","defaultLinkRender","_ref","tagName","attributes","content","class","className","prop","as","Fragment","default"],"sources":["C:/Users/utya1/webweb/react-basic/node_modules/linkify-react/dist/linkify-react.es.js"],"sourcesContent":["import * as React from 'react';\nimport { Options, options, tokenize } from 'linkifyjs';\n\n/**\n * Given a string, converts to an array of valid React components\n * (which may include strings)\n * @param {string} str\n * @param {Options} opts\n * @param {{ [elementId: string]: number }} meta\n * @returns {React.ReactNodeArray}\n */\nfunction stringToElements(str, opts, meta) {\n  const tokens = tokenize(str);\n  const elements = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.t === 'nl' && opts.get('nl2br')) {\n      const key = `__linkify-el-${meta.elementId++}`;\n      elements.push(React.createElement('br', {\n        key\n      }));\n    } else if (!token.isLink || !opts.check(token)) {\n      // Regular text\n      elements.push(token.toString());\n    } else {\n      let rendered = opts.render(token);\n      if (!('key' in rendered.props)) {\n        // Ensure generated element has unique key\n        const key = `__linkify-el-${meta.elementId++}`;\n        const props = options.assign({\n          key\n        }, rendered.props);\n        rendered = React.cloneElement(rendered, props);\n      }\n      elements.push(rendered);\n    }\n  }\n  return elements;\n}\n\n// Recursively linkify the contents of the given React Element instance\n/**\n * @template P\n * @template {string | React.JSXElementConstructor<P>} T\n * @param {React.ReactElement<P, T>} element\n * @param {Options} opts\n * @param {{ [elementId: string]: number }} meta\n * @returns {React.ReactElement<P, T>}\n */\nfunction linkifyReactElement(element, opts, meta) {\n  if (React.Children.count(element.props.children) === 0) {\n    // No need to clone if the element had no children\n    return element;\n  }\n  const children = [];\n  React.Children.forEach(element.props.children, child => {\n    if (typeof child === 'string') {\n      // ensure that we always generate unique element IDs for keys\n      children.push.apply(children, stringToElements(child, opts, meta));\n    } else if (React.isValidElement(child)) {\n      if (typeof child.type === 'string' && opts.ignoreTags.indexOf(child.type.toUpperCase()) >= 0) {\n        // Don't linkify this element\n        children.push(child);\n      } else {\n        children.push(linkifyReactElement(child, opts, meta));\n      }\n    } else {\n      // Unknown element type, just push\n      children.push(child);\n    }\n  });\n\n  // Set a default unique key, copy over remaining props\n  const key = `__linkify-el-${meta.elementId++}`;\n  const newProps = options.assign({\n    key\n  }, element.props);\n  return React.cloneElement(element, newProps, children);\n}\n\n/**\n * @template P\n * @template {string | React.JSXElementConstructor<P>} T\n * @param {P & { as?: T, tagName?: T, options?: import('linkifyjs').Opts, children?: React.ReactNode}} props\n * @returns {React.ReactElement<P, T>}\n */\nconst Linkify = props => {\n  // Copy over all non-linkify-specific props\n  let linkId = 0;\n  const defaultLinkRender = _ref => {\n    let {\n      tagName,\n      attributes,\n      content\n    } = _ref;\n    attributes.key = `__linkify-lnk-${linkId++}`;\n    if (attributes.class) {\n      attributes.className = attributes.class;\n      delete attributes.class;\n    }\n    return React.createElement(tagName, attributes, content);\n  };\n  const newProps = {\n    key: '__linkify-wrapper'\n  };\n  for (const prop in props) {\n    if (prop !== 'options' && prop !== 'as' && prop !== 'tagName' && prop !== 'children') {\n      newProps[prop] = props[prop];\n    }\n  }\n  const opts = new Options(props.options, defaultLinkRender);\n  const as = props.as || props.tagName || React.Fragment || 'span';\n  const children = props.children;\n  const element = React.createElement(as, newProps, children);\n  return linkifyReactElement(element, opts, {\n    elementId: 0\n  });\n};\n\nexport { Linkify as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}